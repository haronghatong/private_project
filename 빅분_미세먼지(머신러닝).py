# -*- coding: utf-8 -*-
"""빅분 미세먼지(머신러닝).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1g93peAp2-WoDxkj_CrOE1BwIxePfLTVU
"""

# 한글 폰트 설치 (Nanum Gothic)
!apt-get -qq -y install fonts-nanum

# 한글 폰트 확인
import matplotlib.font_manager as fm
# Call the public method to update the font cache
fm.fontManager.addfont('/usr/share/fonts/truetype/nanum/NanumGothic.ttf') # This assumes NanumGothic.ttf is the font file name. You might need to adjust the path.

# 설치된 폰트 확인
for font in fm.fontManager.ttflist:
    if 'Nanum' in font.name:
        print(font.name)


import matplotlib.pyplot as plt

plt.rc('font', family='NanumGothic')

"""#데이터 불러오기"""

from google.colab import files
uploaded = files.upload()

import pandas as pd

# 인코딩을 지정하여 파일 읽기
df = pd.read_csv('경기도대기환경정보일평균자료.csv', encoding='cp949')

# 데이터 확인
print(df.head())

"""# 데이터 전처리"""

import pandas as pd

# 측정일자를 datetime 형식으로 변환
df['측정일자'] = pd.to_datetime(df['측정일자'], format='%Y%m%d')

# 변환된 데이터 확인
print(df.head())

# 평균으로 대체
df['PM10측정값(㎍/㎥)'].fillna(df['PM10측정값(㎍/㎥)'].mean(), inplace=True)

# 중앙값으로 대체
df['PM25측정값(㎍/㎥)'].fillna(df['PM25측정값(㎍/㎥)'].median(), inplace=True)

# 지정된 값으로 대체
df.fillna(0, inplace=True)

df.isnull().sum()

# 데이터 타입 확인
print(df.dtypes)

# 변환 예시: 수치형으로 변환
df['PM10측정값(㎍/㎥)'] = pd.to_numeric(df['PM10측정값(㎍/㎥)'], errors='coerce')
df['PM25측정값(㎍/㎥)'] = pd.to_numeric(df['PM25측정값(㎍/㎥)'], errors='coerce')

df.head()

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

suwon_data = df[df['도시명'] == '수원시'].copy()
suwon_data = suwon_data.sort_values(by=['측정장소명', '측정일자'])

# 이상치 제거 예제 (IQR 사용)
Q1 = suwon_data['PM10측정값(㎍/㎥)'].quantile(0.25)
Q3 = suwon_data['PM10측정값(㎍/㎥)'].quantile(0.75)
IQR = Q3 - Q1
suwon_data = suwon_data[(suwon_data['PM10측정값(㎍/㎥)'] >= Q1 - 1.5 * IQR) &
                        (suwon_data['PM10측정값(㎍/㎥)'] <= Q3 + 1.5 * IQR)]

suwon_data = df[df['도시명'] == '수원시'].copy()
suwon_data = suwon_data.sort_values(by=['측정장소명', '측정일자'])

# 이상치 제거 예제 (IQR 사용)
Q2 = suwon_data['PM25측정값(㎍/㎥)'].quantile(0.25)
Q4 = suwon_data['PM25측정값(㎍/㎥)'].quantile(0.75)
IQR = Q4 - Q2
suwon_data = suwon_data[(suwon_data['PM25측정값(㎍/㎥)'] >= Q2 - 1.5 * IQR) &
                        (suwon_data['PM25측정값(㎍/㎥)'] <= Q4 + 1.5 * IQR)]

suwon_data.head()

from sklearn.preprocessing import MinMaxScaler

# 스케일링 대상 열
columns_to_scale = ['PM10측정값(㎍/㎥)', 'PM25측정값(㎍/㎥)']

# 스케일러 초기화
scaler = MinMaxScaler(feature_range=(0, 1))

# 스케일링 수행
scaled_values = scaler.fit_transform(suwon_data[columns_to_scale])

# 스케일링된 값을 원본 데이터프레임에 다시 삽입
suwon_data[columns_to_scale] = scaled_values

# 결과 확인
print(suwon_data.head())

"""# RandomForestRegressor"""

from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt
import numpy as np

# 측정 장소별 학습 및 평가 결과 저장
results = {}

# 측정 장소별로 데이터 그룹화 및 학습
for location in suwon_data['측정장소명'].unique():
    print(f"\n[측정장소: {location}]")

    # 특정 측정 장소 데이터 필터링
    location_data = suwon_data[suwon_data['측정장소명'] == location]

    # 필요한 컬럼만 선택
    data = location_data[['PM10측정값(㎍/㎥)', 'PM25측정값(㎍/㎥)']].values

    # 시계열 데이터 생성
    seq_length = 3  # 시계열 길이
    X, y_pm10, y_pm25 = [], [], []
    for i in range(seq_length, len(data)):
        X.append(data[i-seq_length:i])  # 입력 데이터
        y_pm10.append(data[i, 0])  # PM10 타겟
        y_pm25.append(data[i, 1])  # PM25 타겟

    X = np.array(X)
    y_pm10 = np.array(y_pm10)
    y_pm25 = np.array(y_pm25)

    # 데이터 분리
    train_size = int(len(X) * 0.8)
    X_train, X_test = X[:train_size], X[train_size:]
    y_pm10_train, y_pm10_test = y_pm10[:train_size], y_pm10[train_size:]
    y_pm25_train, y_pm25_test = y_pm25[:train_size], y_pm25[train_size:]

    # 2차원 형태로 변환 (RandomForest는 2D 입력만 허용)
    X_train_flat = X_train.reshape(X_train.shape[0], -1)
    X_test_flat = X_test.reshape(X_test.shape[0], -1)

    # Random Forest 학습 (PM10)
    rf_pm10 = RandomForestRegressor(n_estimators=100, random_state=42)
    rf_pm10.fit(X_train_flat, y_pm10_train)
    y_pm10_pred = rf_pm10.predict(X_test_flat)
    rmse_pm10 = np.sqrt(mean_squared_error(y_pm10_test, y_pm10_pred))

    # Random Forest 학습 (PM25)
    rf_pm25 = RandomForestRegressor(n_estimators=100, random_state=42)
    rf_pm25.fit(X_train_flat, y_pm25_train)
    y_pm25_pred = rf_pm25.predict(X_test_flat)
    rmse_pm25 = np.sqrt(mean_squared_error(y_pm25_test, y_pm25_pred))

    # 결과 저장
    results[location] = {
        'PM10_RMSE': rmse_pm10,
        'PM25_RMSE': rmse_pm25,
        'PM10_Test': y_pm10_test,
        'PM10_Pred': y_pm10_pred,
        'PM25_Test': y_pm25_test,
        'PM25_Pred': y_pm25_pred,
    }


    print(f"PM10 RMSE: {rmse_pm10:.4f}")
    print(f"PM25 RMSE: {rmse_pm25:.4f}")

future_days = 7  # 예측할 미래 일수

# 각 측정 장소별 미래 예측 결과 저장
future_predictions = {}

for location in suwon_data['측정장소명'].unique():
    print(f"\n[측정장소: {location}]")

    # 특정 측정 장소 데이터 필터링
    location_data = suwon_data[suwon_data['측정장소명'] == location]

    # 필요한 컬럼만 선택
    data = location_data[['PM10측정값(㎍/㎥)', 'PM25측정값(㎍/㎥)']].values

    # 시계열 데이터 생성
    seq_length = 3  # 시계열 길이
    X, y_pm10, y_pm25 = [], [], []
    for i in range(seq_length, len(data)):
        X.append(data[i-seq_length:i])  # 입력 데이터
        y_pm10.append(data[i, 0])  # PM10 타겟
        y_pm25.append(data[i, 1])  # PM25 타겟

    X = np.array(X)
    y_pm10 = np.array(y_pm10)
    y_pm25 = np.array(y_pm25)

    # 데이터 분리
    train_size = int(len(X) * 0.8)
    X_train, X_test = X[:train_size], X[train_size:]
    y_pm10_train, y_pm10_test = y_pm10[:train_size], y_pm10[train_size:]
    y_pm25_train, y_pm25_test = y_pm25[:train_size], y_pm25[train_size:]

    # 2차원 형태로 변환 (RandomForest는 2D 입력만 허용)
    X_train_flat = X_train.reshape(X_train.shape[0], -1)
    X_test_flat = X_test.reshape(X_test.shape[0], -1)

    # Random Forest 학습 (PM10)
    rf_pm10 = RandomForestRegressor(n_estimators=100, random_state=42)
    rf_pm10.fit(X_train_flat, y_pm10_train)

    # Random Forest 학습 (PM25)
    rf_pm25 = RandomForestRegressor(n_estimators=100, random_state=42)
    rf_pm25.fit(X_train_flat, y_pm25_train)

    # 미래 예측
    recent_data = X_test_flat[-1:]  # 테스트 데이터의 마지막 샘플 사용
    future_pm10 = []
    future_pm25 = []

    for _ in range(future_days):
        # PM10 예측
        next_pm10 = rf_pm10.predict(recent_data)[0]
        future_pm10.append(next_pm10)

        # PM25 예측
        next_pm25 = rf_pm25.predict(recent_data)[0]
        future_pm25.append(next_pm25)

        # 새로운 예측 값을 추가하여 시계열 데이터를 업데이트
        new_data = np.array([next_pm10, next_pm25]).reshape(1, -1)
        recent_data = np.hstack((recent_data[:, 2:], new_data))

    # 결과 저장
    future_predictions[location] = {
        'PM10_Predictions': future_pm10,
        'PM25_Predictions': future_pm25
    }

    print(f"미래 {future_days}일 PM10 예측값:", future_pm10)
    print(f"미래 {future_days}일 PM25 예측값:", future_pm25)

def visualize_future_predictions(location, predictions, future_days):
    """
    측정 장소별 미래 예측 결과 시각화
    Args:
        location: 측정 장소명
        predictions: 미래 예측 결과 딕셔너리
        future_days: 예측할 미래 일수
    """
    plt.figure(figsize=(12, 6))
    plt.plot(range(future_days), predictions['PM10_Predictions'], label='PM10 예측값', color='blue', marker='o')
    plt.plot(range(future_days), predictions['PM25_Predictions'], label='PM25 예측값', color='green', marker='x')
    plt.title(f'{location} - 미래 {future_days}일 예측 결과', fontsize=16)
    plt.xlabel('미래 일수', fontsize=12)
    plt.ylabel('농도 (㎍/㎥)', fontsize=12)
    plt.legend(fontsize=12)
    plt.grid(True)
    plt.show()

# 시각화 실행
for location, predictions in future_predictions.items():
    visualize_future_predictions(location, predictions, future_days)

import pandas as pd

# 미래 예측 결과를 데이터프레임으로 변환
average_predictions = []

for location, predictions in future_predictions.items():
    avg_pm10 = sum(predictions['PM10_Predictions']) / len(predictions['PM10_Predictions'])
    avg_pm25 = sum(predictions['PM25_Predictions']) / len(predictions['PM25_Predictions'])
    average_predictions.append({'측정장소명': location, '평균_PM10': avg_pm10, '평균_PM25': avg_pm25})

# 데이터프레임 생성
average_df = pd.DataFrame(average_predictions)

# PM10 평균값 기준 상위 3개 장소
top3_pm10 = average_df.nlargest(3, '평균_PM10')

# PM25 평균값 기준 상위 3개 장소
top3_pm25 = average_df.nlargest(3, '평균_PM25')

# 결과 출력
print("PM10 평균값 기준 상위 3개 장소:")
print(top3_pm10)

print("\nPM25 평균값 기준 상위 3개 장소:")
print(top3_pm25)

"""#XGBRegressor


"""

from xgboost import XGBRegressor
from sklearn.metrics import mean_squared_error
import numpy as np

# 측정 장소별 학습 및 평가 결과 저장
xgb_results = {}

# 측정 장소별로 데이터 그룹화 및 학습
for location in suwon_data['측정장소명'].unique():
    print(f"\n[측정장소: {location}]")

    # 특정 측정 장소 데이터 필터링
    location_data = suwon_data[suwon_data['측정장소명'] == location]

    # 필요한 컬럼만 선택
    data = location_data[['PM10측정값(㎍/㎥)', 'PM25측정값(㎍/㎥)']].values

    # 시계열 데이터 생성
    seq_length = 3  # 시계열 길이
    X, y_pm10, y_pm25 = [], [], []
    for i in range(seq_length, len(data)):
        X.append(data[i-seq_length:i])  # 입력 데이터
        y_pm10.append(data[i, 0])  # PM10 타겟
        y_pm25.append(data[i, 1])  # PM25 타겟

    X = np.array(X)
    y_pm10 = np.array(y_pm10)
    y_pm25 = np.array(y_pm25)

    # 데이터 분리
    train_size = int(len(X) * 0.8)
    X_train, X_test = X[:train_size], X[train_size:]
    y_pm10_train, y_pm10_test = y_pm10[:train_size], y_pm10[train_size:]
    y_pm25_train, y_pm25_test = y_pm25[:train_size], y_pm25[train_size:]

    # 2차원 형태로 변환 (XGBoost는 2D 입력만 허용)
    X_train_flat = X_train.reshape(X_train.shape[0], -1)
    X_test_flat = X_test.reshape(X_test.shape[0], -1)

    # XGBoost 학습 (PM10)
    xgb_pm10 = XGBRegressor(n_estimators=100, learning_rate=0.1, max_depth=5, random_state=42)
    xgb_pm10.fit(X_train_flat, y_pm10_train)
    y_pm10_pred = xgb_pm10.predict(X_test_flat)
    rmse_pm10 = np.sqrt(mean_squared_error(y_pm10_test, y_pm10_pred))

    # XGBoost 학습 (PM25)
    xgb_pm25 = XGBRegressor(n_estimators=100, learning_rate=0.1, max_depth=5, random_state=42)
    xgb_pm25.fit(X_train_flat, y_pm25_train)
    y_pm25_pred = xgb_pm25.predict(X_test_flat)
    rmse_pm25 = np.sqrt(mean_squared_error(y_pm25_test, y_pm25_pred))

    # 결과 저장
    xgb_results[location] = {
        'PM10_RMSE': rmse_pm10,
        'PM25_RMSE': rmse_pm25,
        'PM10_Test': y_pm10_test,
        'PM10_Pred': y_pm10_pred,
        'PM25_Test': y_pm25_test,
        'PM25_Pred': y_pm25_pred,
    }

    print(f"PM10 RMSE: {rmse_pm10:.4f}")
    print(f"PM25 RMSE: {rmse_pm25:.4f}")

future_days = 7  # 예측할 미래 일수

# 각 측정 장소별 미래 예측 결과 저장
future_predictions = {}

for location in suwon_data['측정장소명'].unique():
    print(f"\n[측정장소: {location}]")

    # 특정 측정 장소 데이터 필터링
    location_data = suwon_data[suwon_data['측정장소명'] == location]

    # 필요한 컬럼만 선택
    data = location_data[['PM10측정값(㎍/㎥)', 'PM25측정값(㎍/㎥)']].values

    # 시계열 데이터 생성
    seq_length = 3  # 시계열 길이
    X, y_pm10, y_pm25 = [], [], []
    for i in range(seq_length, len(data)):
        X.append(data[i-seq_length:i])  # 입력 데이터
        y_pm10.append(data[i, 0])  # PM10 타겟
        y_pm25.append(data[i, 1])  # PM25 타겟

    X = np.array(X)
    y_pm10 = np.array(y_pm10)
    y_pm25 = np.array(y_pm25)

    # 데이터 분리
    train_size = int(len(X) * 0.8)
    X_train, X_test = X[:train_size], X[train_size:]
    y_pm10_train, y_pm10_test = y_pm10[:train_size], y_pm10[train_size:]
    y_pm25_train, y_pm25_test = y_pm25[:train_size], y_pm25[train_size:]

    # 2차원 형태로 변환 (RandomForest는 2D 입력만 허용)
    X_train_flat = X_train.reshape(X_train.shape[0], -1)
    X_test_flat = X_test.reshape(X_test.shape[0], -1)

    # XGBRegressor 학습 (PM10)
    rf_pm10 = XGBRegressor(n_estimators=100, random_state=42)
    rf_pm10.fit(X_train_flat, y_pm10_train)

    # XGBRegressor 학습 (PM25)
    rf_pm25 = XGBRegressor(n_estimators=100, random_state=42)
    rf_pm25.fit(X_train_flat, y_pm25_train)

    # 미래 예측
    recent_data = X_test_flat[-1:]  # 테스트 데이터의 마지막 샘플 사용
    future_pm10 = []
    future_pm25 = []

    for _ in range(future_days):
        # PM10 예측
        next_pm10 = rf_pm10.predict(recent_data)[0]
        future_pm10.append(next_pm10)

        # PM25 예측
        next_pm25 = rf_pm25.predict(recent_data)[0]
        future_pm25.append(next_pm25)

        # 새로운 예측 값을 추가하여 시계열 데이터를 업데이트
        new_data = np.array([next_pm10, next_pm25]).reshape(1, -1)
        recent_data = np.hstack((recent_data[:, 2:], new_data))

    # 결과 저장
    future_predictions[location] = {
        'PM10_Predictions': future_pm10,
        'PM25_Predictions': future_pm25
    }

    print(f"미래 {future_days}일 PM10 예측값:", future_pm10)
    print(f"미래 {future_days}일 PM25 예측값:", future_pm25)

def visualize_future_predictions(location, predictions, future_days):
    """
    측정 장소별 미래 예측 결과 시각화
    Args:
        location: 측정 장소명
        predictions: 미래 예측 결과 딕셔너리
        future_days: 예측할 미래 일수
    """
    plt.figure(figsize=(12, 6))
    plt.plot(range(future_days), predictions['PM10_Predictions'], label='PM10 예측값', color='blue', marker='o')
    plt.plot(range(future_days), predictions['PM25_Predictions'], label='PM25 예측값', color='green', marker='x')
    plt.title(f'{location} - 미래 {future_days}일 예측 결과', fontsize=16)
    plt.xlabel('미래 일수', fontsize=12)
    plt.ylabel('농도 (㎍/㎥)', fontsize=12)
    plt.legend(fontsize=12)
    plt.grid(True)
    plt.show()

# 시각화 실행
for location, predictions in future_predictions.items():
    visualize_future_predictions(location, predictions, future_days)

import pandas as pd

# 미래 예측 결과를 데이터프레임으로 변환
average_predictions = []

for location, predictions in future_predictions.items():
    avg_pm10 = sum(predictions['PM10_Predictions']) / len(predictions['PM10_Predictions'])
    avg_pm25 = sum(predictions['PM25_Predictions']) / len(predictions['PM25_Predictions'])
    average_predictions.append({'측정장소명': location, '평균_PM10': avg_pm10, '평균_PM25': avg_pm25})

# 데이터프레임 생성
average_df = pd.DataFrame(average_predictions)

# PM10 평균값 기준 상위 3개 장소
top3_pm10 = average_df.nlargest(3, '평균_PM10')

# PM25 평균값 기준 상위 3개 장소
top3_pm25 = average_df.nlargest(3, '평균_PM25')

# 결과 출력
print("PM10 평균값 기준 상위 3개 장소:")
print(top3_pm10)

print("\nPM25 평균값 기준 상위 3개 장소:")
print(top3_pm25)

