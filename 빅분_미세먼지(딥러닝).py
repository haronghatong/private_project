# -*- coding: utf-8 -*-
"""빅분 미세먼지(딥러닝).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jM3U2kkF_ymzo8C-dC2hwEjsgAYunmZU

#데이터 불러오기
"""

# 한글 폰트 설치 (Nanum Gothic)
!apt-get -qq -y install fonts-nanum

# 한글 폰트 확인
import matplotlib.font_manager as fm
# Call the public method to update the font cache
fm.fontManager.addfont('/usr/share/fonts/truetype/nanum/NanumGothic.ttf') # This assumes NanumGothic.ttf is the font file name. You might need to adjust the path.

# 설치된 폰트 확인
for font in fm.fontManager.ttflist:
    if 'Nanum' in font.name:
        print(font.name)

import matplotlib.pyplot as plt

plt.rc('font', family='NanumGothic')

from google.colab import files
uploaded = files.upload()

import pandas as pd

# 인코딩을 지정하여 파일 읽기
df = pd.read_csv('경기도대기환경정보일평균자료.csv', encoding='cp949')

# 데이터 확인
print(df.head())

"""# 데이터 전처리"""

import pandas as pd

# 측정일자를 datetime 형식으로 변환
df['측정일자'] = pd.to_datetime(df['측정일자'], format='%Y%m%d')

# 변환된 데이터 확인
print(df.head())

# 평균으로 대체
df['PM10측정값(㎍/㎥)'].fillna(df['PM10측정값(㎍/㎥)'].mean(), inplace=True)

# 중앙값으로 대체
df['PM25측정값(㎍/㎥)'].fillna(df['PM25측정값(㎍/㎥)'].median(), inplace=True)

# 지정된 값으로 대체
df.fillna(0, inplace=True)

df.isnull().sum()

# 데이터 타입 확인
print(df.dtypes)

# 변환 예시: 수치형으로 변환
df['PM10측정값(㎍/㎥)'] = pd.to_numeric(df['PM10측정값(㎍/㎥)'], errors='coerce')
df['PM25측정값(㎍/㎥)'] = pd.to_numeric(df['PM25측정값(㎍/㎥)'], errors='coerce')

df.head()

"""# LSTM"""

import pandas as pd
import numpy as np
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

suwon_data = df[df['도시명'] == '수원시'].copy()
suwon_data = suwon_data.sort_values(by=['측정장소명', '측정일자'])

# 이상치 제거 예제 (IQR 사용)
Q1 = suwon_data['PM10측정값(㎍/㎥)'].quantile(0.25)
Q3 = suwon_data['PM10측정값(㎍/㎥)'].quantile(0.75)
IQR = Q3 - Q1
suwon_data = suwon_data[(suwon_data['PM10측정값(㎍/㎥)'] >= Q1 - 1.5 * IQR) &
                        (suwon_data['PM10측정값(㎍/㎥)'] <= Q3 + 1.5 * IQR)]

suwon_data = df[df['도시명'] == '수원시'].copy()
suwon_data = suwon_data.sort_values(by=['측정장소명', '측정일자'])

# 이상치 제거 예제 (IQR 사용)
Q2 = suwon_data['PM25측정값(㎍/㎥)'].quantile(0.25)
Q4 = suwon_data['PM25측정값(㎍/㎥)'].quantile(0.75)
IQR = Q4 - Q2
suwon_data = suwon_data[(suwon_data['PM25측정값(㎍/㎥)'] >= Q2 - 1.5 * IQR) &
                        (suwon_data['PM25측정값(㎍/㎥)'] <= Q4 + 1.5 * IQR)]

suwon_data.head()

from sklearn.preprocessing import MinMaxScaler

# 스케일링 대상 열
columns_to_scale = ['PM10측정값(㎍/㎥)', 'PM25측정값(㎍/㎥)']

# 스케일러 초기화
scaler = MinMaxScaler(feature_range=(0, 1))

# 스케일링 수행
scaled_values = scaler.fit_transform(suwon_data[columns_to_scale])

# 스케일링된 값을 원본 데이터프레임에 다시 삽입
suwon_data[columns_to_scale] = scaled_values

# 결과 확인
print(suwon_data.head())

"""# 학습&평가 LSTM"""

# 결과 저장용 리스트
results = []

# 각 측정 장소별로 LSTM 적용
for location in suwon_data['측정장소명'].unique():
    # 데이터 필터링
    location_data = suwon_data[suwon_data['측정장소명'] == location].copy()
    location_data.set_index('측정일자', inplace=True)

    # 필요한 열만 선택
    dataset = location_data[['PM10측정값(㎍/㎥)', 'PM25측정값(㎍/㎥)']].values

    # 데이터 정규화
    scaler = MinMaxScaler(feature_range=(0, 1))
    dataset_scaled = scaler.fit_transform(dataset)

    # 시계열 데이터 생성
    def create_sequences(data, seq_length=3):
        X, y = [], []
        for i in range(seq_length, len(data)):
            X.append(data[i-seq_length:i])
            y.append(data[i, 0])  # PM10 예측
        return np.array(X), np.array(y)

    seq_length = 3  # 과거 3일 데이터를 기반으로 예측
    X, y = create_sequences(dataset_scaled, seq_length)

    # 훈련 및 테스트 데이터 분리
    train_size = int(len(X) * 0.8)
    X_train, X_test = X[:train_size], X[train_size:]
    y_train, y_test = y[:train_size], y[train_size:]

    # LSTM 모델 정의
    model = Sequential()
    model.add(LSTM(50, activation='relu', input_shape=(seq_length, X.shape[2])))
    model.add(Dense(1))
    model.compile(optimizer='adam', loss='mse')

    # 모델 학습
    model.fit(X_train, y_train, epochs=50, batch_size=32, verbose=0)

    # 예측
    y_pred = model.predict(X_test)

    # 역정규화
    y_test_rescaled = scaler.inverse_transform(np.hstack((y_test.reshape(-1, 1), np.zeros((y_test.shape[0], 1)))))
    y_pred_rescaled = scaler.inverse_transform(np.hstack((y_pred, np.zeros((y_pred.shape[0], 1)))))

    # RMSE 계산
    rmse = np.sqrt(mean_squared_error(y_test_rescaled[:, 0], y_pred_rescaled[:, 0]))
    results.append({'측정장소명': location, 'PM10_RMSE': rmse})

    # 시각화 (선택 사항)
    plt.figure(figsize=(12, 6))
    plt.plot(y_test_rescaled[:, 0], label='실제값', marker='o')
    plt.plot(y_pred_rescaled[:, 0], label='예측값', marker='x')
    plt.title(f'{location} - PM10 예측 결과')
    plt.legend()
    plt.show()

# 결과 출력
results_df = pd.DataFrame(results)
print(results_df)

"""# 예측"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

# 미래 예측 함수
def predict_future(model, input_data, seq_length=3, days_to_predict=7):
    predictions = []
    current_data = input_data[-seq_length:]  # 마지막 시퀀스를 사용하여 예측 시작
    for _ in range(days_to_predict):
        prediction = model.predict(current_data[np.newaxis, :, :], verbose=0)
        predictions.append(prediction[0])  # PM10과 PM25 모두 저장
        current_data = np.vstack([current_data[1:], prediction])
    return np.array(predictions)

# 결과 저장용 리스트
results = []

# 각 측정 장소별로 데이터 처리 및 RMSE 계산
for location in suwon_data['측정장소명'].unique():
    # 데이터 필터링
    location_data = suwon_data[suwon_data['측정장소명'] == location].copy()
    location_data.set_index('측정일자', inplace=True)

    # 필요한 열만 선택
    dataset = location_data[['PM10측정값(㎍/㎥)', 'PM25측정값(㎍/㎥)']].values

    # 데이터 정규화
    scaler = MinMaxScaler(feature_range=(0, 1))
    dataset_scaled = scaler.fit_transform(dataset)

    # 시계열 데이터 생성 함수
    def create_sequences(data, seq_length=3):
        X, y = [], []
        for i in range(seq_length, len(data)):
            X.append(data[i-seq_length:i])
            y.append(data[i])  # PM10과 PM25를 동시에 예측
        return np.array(X), np.array(y)

    seq_length = 3  # 과거 3일 데이터를 기반으로 예측
    X, y = create_sequences(dataset_scaled, seq_length)

    # 훈련 및 테스트 데이터 분리
    train_size = int(len(X) * 0.8)
    X_train, X_test = X[:train_size], X[train_size:]
    y_train, y_test = y[:train_size], y[train_size:]

    # LSTM 모델 정의
    model = Sequential()
    model.add(LSTM(50, activation='relu', input_shape=(seq_length, X.shape[2])))
    model.add(Dense(2))  # PM10과 PM25를 동시에 예측
    model.compile(optimizer='adam', loss='mse')

    # 모델 학습
    model.fit(X_train, y_train, epochs=50, batch_size=32, verbose=0)

    # 예측
    y_pred = model.predict(X_test)

    # 역정규화
    y_test_rescaled = scaler.inverse_transform(y_test)
    y_pred_rescaled = scaler.inverse_transform(y_pred)

    # RMSE 계산 (PM10, PM25 각각)
    rmse_pm10 = np.sqrt(mean_squared_error(y_test_rescaled[:, 0], y_pred_rescaled[:, 0]))
    rmse_pm25 = np.sqrt(mean_squared_error(y_test_rescaled[:, 1], y_pred_rescaled[:, 1]))

    # 미래 7일 예측
    future_predictions = predict_future(model, dataset_scaled, seq_length=seq_length, days_to_predict=7)
    future_predictions_rescaled = scaler.inverse_transform(future_predictions)

    # 결과 저장
    results.append({
        '측정장소명': location,
        'PM10_RMSE': rmse_pm10,
        'PM25_RMSE': rmse_pm25
    })

    # 시각화: 테스트 데이터 실제값 및 예측값 (PM10, PM25)
    plt.figure(figsize=(12, 6))
    plt.plot(y_test_rescaled[:, 0], label='실제값 (PM10)', marker='o')
    plt.plot(y_pred_rescaled[:, 0], label='예측값 (PM10)', marker='x')
    plt.title(f'{location} - PM10 테스트 데이터 예측 결과')
    plt.xlabel('데이터 포인트')
    plt.ylabel('PM10 측정값(㎍/㎥)')
    plt.legend()
    plt.grid()
    plt.show()

    plt.figure(figsize=(12, 6))
    plt.plot(y_test_rescaled[:, 1], label='실제값 (PM25)', marker='o')
    plt.plot(y_pred_rescaled[:, 1], label='예측값 (PM25)', marker='x', color='orange')
    plt.title(f'{location} - PM25 테스트 데이터 예측 결과')
    plt.xlabel('데이터 포인트')
    plt.ylabel('PM25 측정값(㎍/㎥)')
    plt.legend()
    plt.grid()
    plt.show()

    # 시각화: 미래 7일 예측 (PM10, PM25)
    plt.figure(figsize=(12, 6))
    plt.plot(range(1, 8), future_predictions_rescaled[:, 0], marker='o', label='미래 PM10 예측값')
    plt.plot(range(1, 8), future_predictions_rescaled[:, 1], marker='x', label='미래 PM25 예측값', color='orange')
    plt.title(f'{location} - 향후 7일 예측 결과')
    plt.xlabel('일수')
    plt.ylabel('측정값(㎍/㎥)')
    plt.legend()
    plt.grid()
    plt.show()

# 결과 출력
results_df = pd.DataFrame(results)
print(results_df)

